local ini_parts   = itms_manager.ini_parts
get_config = arti_outfits_mcm.get_config
gc = game.translate_string
-- id of current outfit
local current_outfit = 0
-- part names to conditions
local current_outfit_parts = {}
-- actor's current damage immunities, factoring in belt items and condition of outfit
local current_outfit_immunity = {}

-- damage 2 immunity:
local d2i = {
    ["chemical_burn"] = "chemical_burn_immunity",
    ["shock"] = "shock_immunity",
    ["burn"] = "burn_immunity",
    ["strike"] = "strike_immunity",
    ["wound"] = "wound_immunity",
    ["fire_wound"] ="fire_wound_immunity",
    ["explosion"] = "explosion_immunity"
}
-- immunity 2 modifiers (damage reduction)
-- these can't exceed 1 otherwise the parts die faster than the suit
-- 1 = helmet, 2 = fabric, 3 = retardants, 4 = ballistics, 5 = exo upports
-- chemical - extra damage to support, all others equal
-- shock - rip your servos
-- burn - fabrics only, partially melt ballistics
-- wound (animal)- lots of damage to fabrics/retardants, negligible for supports/helm
-- explosion - fucks up everything i guess
-- fire_wound (bullet) - more damage to ballistics, less to everything else (it's just punching sewable holes)
-- strike - what even is this lmao
local i2m = {
    -- ["chemical_burn_immunity"] = {1.4, 2.2, 0.3, 3, 3},
    -- ["shock_immunity"] = {0.2, 0.2, 0.2, 0.2, 4},
    -- ["burn_immunity"] =  {1, 4, 0.5, 2, 0.5},
    -- ["strike_immunity"] =  {1, 1, 1, 1, 1},
    -- ["wound_immunity"] = {0, 3, 3, 1, 0},
    -- ["fire_wound_immunity"] = {1.5, 1.5, 1.5, 1, 0.5},
    -- ["explosion_immunity"] = {2, 2, 2, 1, 1}
    
    ["chemical_burn_immunity"] =    {0.8, 0.7, 0.3, 1,   1  },
    ["shock_immunity"] =            {0.2, 0.2, 0.2, 0.2, 1  },
    ["burn_immunity"] =             {0.5, 1,   0.5, 0.7, 0.5},
    ["wound_immunity"] =            {0,   1,   1,   0.3, 0  },
    ["explosion_immunity"] =        {1,   1,   1,   0.5, 0.5},
    ["fire_wound_immunity"] =       {1,   1,   1,   0.7, 0.5},
    ["strike_immunity"] =           {1,   1,   1,   1,   1  }
}

local parts_map = {}

local enable_debug = true
function print_dbg(text, ...) 
	if enable_debug then
		printf("arti_outfits | %s | " .. text, time_global(), ...)
	end
end

local function dump_immunities()
    if enable_debug and current_outfit ~= 0 then
        for k,v in pairs(current_outfit_immunity) do
            print_dbg("Current player immunity to %s: %s", k, v)
        end
    end
end

function get_parts(outfit)
    if not has_parts(outfit) then return nil end
    local outfit_parts = outfit:id() == current_outfit and current_outfit_parts or item_parts.get_parts_con(outfit, nil, true)
    return outfit_parts
end

function has_parts(outfit)
    if outfit and IsOutfit(outfit)then
        local parts = ini_parts:r_string_ex("con_parts_list", outfit:section())
        if parts then 
            -- print_dbg("Found these parts "..parts)
        end
		return parts ~= nil
	else 
		return false
	end
end

function is_part(sec)
    return string.find(sec, "prt_o") or string.find(sec, "helm_")
end
-- apply amount damage to all parts of the outfit
-- if it is lower than certain threshold, ignore it altogether
-- todo helmet damage should be affected by helmet immunities?
local DAMAGE_THRESHOLD = 1
local function degrade_parts(type, amount, helmet_only)
    print_dbg("Degrading parts, actor took %s amount of %s type damage. Player shot in head? %s", amount, type, helmet_only)
    for k,v in pairs(current_outfit_parts) do
        local rank = rank_component(k)
        print_dbg("Checking damage for component %s", k)
        -- ignore non-part entries
        if not is_part(k) then
        -- bullets only damage helmet, or armor, not both
        elseif (type == "fire_wound" and ((rank == 1 and helmet_only) or (rank ~= 1 and not helmet_only))) or type ~= "fire_wound" then
            -- modify damage amt against part types and apply to part (out of 100)
            local final_damage = math.floor(100 * amount * (i2m[d2i[type]][rank]))
            if final_damage > DAMAGE_THRESHOLD then
                current_outfit_parts[k] = clamp(v - final_damage , 0, 99) 
                print_dbg("Component %s took %s damage, condition now %s", k, final_damage, current_outfit_parts[k])
            end
        end
    end
    item_parts.set_parts_con(current_outfit, current_outfit_parts)
end

local prev_time = nil

local updated        = 0
local update_step    = 2000 --[ms]
function actor_on_update()
    local tg = time_global()
    if tg < updated then return end
    updated = tg + update_step

    local outfit = db.actor:item_in_slot(7)
    local outfit_id = outfit and outfit:id() or 0
    local do_purge = false
    if outfit and outfit_id ~= current_outfit then
        if has_parts(outfit) then
            current_outfit = outfit_id
            print_dbg("Current outfit set to %s", outfit:section())
            current_outfit_parts = dup_table(item_parts.get_parts_con(outfit, nil, true))
            update_immunities()
            dump_immunities()
        else
            print_dbg("outfit has no parts, purging")
            do_purge = true
        end
    end
    if outfit_id == 0 and current_outfit ~= outfit_id then
        print_dbg("No outfit equipped, purging")
        do_purge = true
    end
    if do_purge then
        current_outfit = 0
        empty_table(current_outfit_parts)
        empty_table(current_outfit_immunity)
    end

end

-- immunities work in a reverse fashion - damage taken times immunity equals damage to armor. the lower the immunity, the less armor damage you take
function update_immunities()
    if current_outfit ~= 0 then
        local outfit = db.actor:item_in_slot(7)
        local immunities_sec =  SYS_GetParam(0,outfit:section(),"immunities_sect")
        for k,v in pairs(d2i) do        
            current_outfit_immunity[k] = SYS_GetParam(2, immunities_sec, v, 0)
        end
    end
end

local dtype = {
	[hit.burn]          = "burn",
	[hit.strike]        = "strike",
	[hit.shock]         = "shock",
	[hit.wound]         = "wound",
	[hit.chemical_burn] = "chemical_burn",
	[hit.explosion]     = "explosion",
	[hit.fire_wound]    = "fire_wound",
}

-- categories of damage are: fabrics, retardants, ballistics, helms, support
local PART_DMG_COEF = 0.9
function actor_on_before_hit(shit,bone_id)
    if current_outfit ~= 0 then
        dump_immunities()
        local immunity_name = d2i[dtype[shit.type]]
        local immunity_val = current_outfit_immunity[dtype[shit.type]]
        if immunity_name then
            local coef = get_config("damage") or PART_DMG_COEF
            local damage_to_armor = immunity_val * shit.power * coef
            -- in case actor got headshot only damage the attached helmet
            local helmet_only = (bone_id == 15 and shit.type == hit.fire_wound)
            print_dbg("Actor took %s type damage with power %s. Actor immunity against damage is %s. Total condition damage is %s.", dtype[shit.type], shit.power, immunity_val, damage_to_armor)
            degrade_parts(dtype[shit.type], damage_to_armor, helmet_only)
        end
    end
end


-- glues, emergency - nothing
-- basic sewing - fabrics only, 50%
-- advanced/heavy - fabrics and retardants, 50-75%
-- repairkit - 100% any, 
local repair_item_restoration = {
    ["sewing_kit_b"] = {20, {["prt_o_fabrics"] = true}},
    ["sewing_kit_a"] = {30, {["prt_o_fabrics"] = true, ["prt_o_retardant"] = true}},
    ["sewing_kit_h"] = {40,{["prt_o_fabrics"] = true, ["prt_o_retardant"] = true}},
    ["helmet_repair_kit"] = {50, {["prt_o_fabrics"] = true, ["prt_o_retardant"] = true, ["prt_o_ballistic"] = true}},
    ["light_repair_kit"] = {50, {["prt_o_fabrics"] = true, ["prt_o_retardant"] = true, ["prt_o_ballistic"] = true}},
    ["medium_repair_kit"] = {50,{["prt_o_fabrics"] = true, ["prt_o_retardant"] = true, ["prt_o_ballistic"] = true}},
    ["heavy_repair_kit"] = {50, {["prt_o_fabrics"] = true, ["prt_o_retardant"] = true, ["prt_o_ballistic"] = true}},
    ["exo_repair_kit"] = {50, {["prt_o_fabrics"] = true, ["prt_o_retardant"] = true, ["prt_o_ballistic"] = true, ["prt_o_support"] = true}},
}

function part_compatible(part_name, repair_name)
    local repair_stats = repair_item_restoration[repair_name]
    if not repair_stats then return false end
    return part_matching(part_name, repair_stats[2])
end

function get_bonus(part, repair_name, outfit_parts)
    -- validate repair item
    local repair_stats = repair_item_restoration[repair_name]
    if not repair_stats then 
        print_dbg("Passed repair item has no max condition restoration")
        return 1 
    end
    restore_base = repair_stats[1]
    restore_parts = repair_stats[2]
    -- validate part (can be nil)
    if not part then 
        print_dbg("Passed support item is nil")
        return 1 
    end
    local part_name = part:section()
    if not is_part(part_name) then return 1 end
    local part_cond = part:condition()
    local part_entry = parts_map[part_name]
    local bonus = 0
    print_dbg("Part: name is %s, condition %s, entry is %s, value in outfit parts: %s", part_name, part_cond, part_entry, outfit_parts[part_name])
    if part_entry and restore_parts[part_entry] then
        -- support item is outfit part - provide up to 30% if non-matching, or 200% if matching
        bonus = outfit_parts[part_name] ~= nil and 2 or 0.3
        bonus = bonus * part_cond
        if rank_component(part_name) == 2 then
            bonus = bonus / 3
        end
    end
    print_dbg("Bonus multiplier for part %s is %s", part_name, bonus)
    return 1 + bonus
end

function part_matching(part_name, part_list)
    local part_type = parts_map[part_name]
    return part_list[part_type]
end
function rank_component(name)
    if string.find(name, "prt_o_support") then
        return 5
    elseif string.find(name, "prt_o_ballistic") then
        return 4
    elseif string.find(name, "prt_o_retardant") then
        return 3
    elseif string.find(name, "prt_o_fabrics") then
        return 2
    else
        return 1
    end
end
local functor = function(t,a,b) 
    local rank_a = a and rank_component(a) or 0
    local rank_b = b and rank_component(b) or 0
    if rank_a ~= rank_b then return rank_a > rank_b
    else
        return a > b 
    end
end

function repair_parts(outfit, repair_item, support_part)
    local id = outfit:id()
    local sec = outfit:section()
    local is_current = id == current_outfit
    print_dbg("Repairing %s with %s and %s", sec, repair_item, support_part and support_part:section() or "none")
    local outfit_parts = get_parts(outfit)
    local new_outfit_parts = apply_parts_repair(outfit_parts, repair_item, support_part, true)
    item_parts.set_parts_con(id, new_outfit_parts)
    if is_current then
        empty_table(current_outfit_parts)
        copy_table(current_outfit_parts, new_outfit_parts)
    end
end

function apply_parts_repair(outfit_parts_original, repair_item, support_part, print)
    print_dbg("Calculating parts repair with %s and support %s", repair_item, support_part and support_part:section() or "none")
    local repair_class = repair_item_restoration[repair_item]
    if not repair_class then return outfit_parts_original end
    local outfit_parts = {}
    copy_table(outfit_parts, outfit_parts_original)
    local remaining_cond = repair_class[1] * get_bonus(support_part, repair_item, outfit_parts)
    local repairable = repair_class[2]
    local str = ""
    print_dbg("Total condition to be restored: %s", remaining_cond)
    for k,v in spairs(outfit_parts, functor) do
        if remaining_cond == 0 then
            break
        elseif string.find(k, "prt_o") then
            if part_matching(k, repairable) then 
                local max_restorable = 99 - v
                local restored = remaining_cond > max_restorable and max_restorable or remaining_cond
                outfit_parts[k] = v + restored
                remaining_cond = remaining_cond - restored
                print_dbg("Restored %s condition to %s, condition now %s, remaining condition is %s.", restored, k, outfit_parts[k], remaining_cond)
                if restored > 0 then
                    local part_name = gc(ini_sys:r_string_ex(k, "inv_name"))
                    local string = strformat(gc("st_part_repaired"), part_name, outfit_parts[k])
                    str = str .. string .. "\\n"
                end

            end
        end
    end
    if str ~= "" and print then
        news_manager.send_tip(db.actor, str, nil, "swiss_knife", 6000)
    end
    return outfit_parts
end

-- used by item repair to get the projected max condition
function get_projected_max(outfit, repair_item, support_part)
    print_dbg("repair sec is %s", repair_item)
    
    if not has_parts(outfit) then return 100 end
    local outfit_parts = get_parts(outfit)
    local new_outfit_parts = apply_parts_repair(outfit_parts, repair_item, support_part,false)
    return average_cond(new_outfit_parts)
end

function tech_restore_parts(outfit)
    local outfit_parts = get_parts(outfit)
    for k,v in pairs(outfit_parts) do
        outfit_parts[k] = 100
    end
    item_parts.set_parts_con(outfit:id(), outfit_parts)
end


function average_cond(parts)
    local total = 0
    local num = 0
    -- print_dbg("Averaging condition of %s parts", #parts)
    for k,v in pairs(parts) do
        if is_part(k) then
            -- print_dbg("Adding %s to total condition %s", v, total)
            total = total + v
            num = num + 1
        end
    end
    local final_cond = 20 + math.floor(0.8*(total/num))
    if final_cond > 97 then final_cond = 100 end
    return final_cond
end

-- Compute max condition based on parts condition
function get_max_condition(outfit)
    if not has_parts(outfit) then return 100 end
    -- print_dbg("Checking for id %s, current is %s", outfit:id(), current_outfit)
    local outfit_parts = get_parts(outfit)
    if outfit_parts then
        return average_cond(outfit_parts)
    else
        return 100
    end
end

-- Round off the condition of the outfit (to be applied after parts repairs are done)
function cap_condition(outfit)
    local outfit_max_condition = get_max_condition(outfit)/100
    if outfit:condition() > outfit_max_condition then
        outfit:set_condition(outfit_max_condition)
    end
    current_outfit = 0
    updated = time_global() - 1
end

-- for reattaching helmet, burn one use of helmet repair kit to swap   
local function on_item_drag_dropped(helmet, outfit, slot_from, slot_to)
    if not has_parts(outfit) then return end
    if not IsHeadgear(helmet) then return end

	local helmet_sec = helmet and helmet:section() or nil
    local outfit_sec = outfit and outfit:section() or nil
    local outfit_parts = item_parts.get_parts_con(outfit, nil, true)
    local helmet_kit = db.actor:object("helmet_repair_kit")
    if not helmet_kit then
        news_manager.send_tip(db.actor, gc("st_no_helmkit"), nil, "swiss_knife", 6000)
        return
    end

    local found_helmet = nil
    local num_parts = 0
    for k,v in pairs(outfit_parts) do
        num_parts = num_parts + 1
        if k == helmet_sec and v < 99 then
            found_helmet = k
        end
    end

    if found_helmet then
        local helm_to_spawn = alife_create(found_helmet, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:id(), false)
        local data = utils_stpk.get_item_data(helm_to_spawn)
        data.condition = outfit_parts[found_helmet]/100
        utils_stpk.set_item_data(data,helm_to_spawn)
        alife():register(helm_to_spawn)

        outfit_parts[found_helmet] = math.floor(helmet:condition() * 100)

        local contribution = (helmet:condition() * 0.8) / (num_parts - 1)
        print_dbg("Helmet contribution to condition: "..contribution)
        outfit:set_condition(outfit:condition() + contribution)
        cap_condition(outfit)

        utils_item.discharge(helmet_kit)
        alife_release_id(helmet:id())
        news_manager.send_tip(db.actor, gc("st_helm_success"), nil, "swiss_knife", 6000)
    else
        -- not found, return error
        news_manager.send_tip(db.actor, gc("st_no_helm"), nil, "swiss_knife", 6000)
    end
end

-- UNUSED
-- return a new condition based on the new parts conditions + old outfit condition
function calc_new_cond(outfit, new_parts, all_parts, max_cond)
    local parts = str_explode(ini_parts:r_string_ex("con_parts_list", outfit:section()), ",")
    local max_cond = all_parts and average_cond(all_parts) or get_max_condition(outfit)
    local current_cond = math.floor(outfit:condition() * 100)
    local condition_per_part = math.floor(80/#parts)
    print_dbg("Outfit: %s. Current condition: %s. Max condition: %s. Condition per part: %s", outfit:section(), current_cond, max_cond, condition_per_part)
    local tot_restored = 0
    for k,v in pairs(new_parts) do
        -- update new current condition and max condition
        local old_cond = all_parts[k]
        tot_restored = tot_restored + math.floor((condition_per_part*v)/100)
        print_dbg("calc_new_cond: part contribution: %s. total condition restored: %s", v, tot_restored)
    end
    current_cond = current_cond + tot_restored
    if current_cond > max_cond then current_cond = max_cond end
    print_dbg("Final outfit condition is %s", current_cond)
    return current_cond
end

-- UNUSED
function set_new_cond(outfit, new_parts, all_parts)
    local cond = calc_new_cond(outfit, new_parts, all_parts)/100
    outfit:set_condition(cond)
    current_outfit = 0
    updated = time_global() - 1
end


OnUIRepair = ui_inventory.UIInventory.RMode_RepairYes

function ui_inventory.UIInventory:RMode_RepairYes()
    
	local obj = level.object_by_id(self.upgr.id)
    OnUIRepair(self)
    if has_parts(obj) then
		tech_restore_parts(obj)
	end
end

EvaluateParts = item_parts.evaluate_parts

function item_parts.evaluate_parts(obj)
    local sec = obj:section()
	sec = ini_sys:r_string_ex(sec,"parent_section") or sec -- for weapons with scopes
	local id = obj:id()
	local m_con = math.ceil(obj:condition() * 100) -- default condition of the item
	
	local parts = ini_parts:r_string_ex("con_parts_list",sec)
	if parts then
		parts = str_explode(parts,",")
		
		local data = se_load_var(id, obj:name(), "parts")

		-- Savegame compatibility. Recalculate with changed parts
		if data and data[sec] then
			for i=1,#parts do
				if (not data[parts[i]]) then
					empty_table(data)
					break
				end
			end
		end
		-- premature terminate if data exists for outfits
		if data and IsOutfit(obj) and not is_empty(parts)  then return
        else
            EvaluateParts(obj)
		end
    end
end


-- reject conflicts, return to monke

function item_repair.UIRepair:InitInventory(n)
	local inv = {}
	local size_t = 0
	
	-- Compatible weapons list to repair
	if n == 1 then
		db.actor:iterate_inventory( function(owner, obj)
			local sec = obj:section()
			local main_section = ini_sys:r_string_ex(sec,"repair_type") or sec
			if (self.repair_only and self.repair_only[main_section]) then
				local con = math.ceil(obj:condition() * 100)
				if (con and con >= (self.min_condition * 100) and con <= self.max_condition * 100) then
					size_t = size_t + 1
					inv[size_t] = obj
				end
			end
		end)
		
		self.CC[1]:Reinit(inv)

	-- Compatible part list to use
	elseif n == 2 then
		local obj_s = self.CC[1]:GetCell_Selected(true)
		if (not obj_s) then
			return
		end
		
		local inf = {}
		local ItemListSec_2 = {} -- to show only one copy of bonus items
		db.actor:iterate_inventory( function(owner, obj)
			local sec = obj:section()
			if (not ItemListSec_2[sec]) and (obj) and (obj:id() ~= obj_s:id()) and (obj:id() ~= self.obj:id()) then
				ItemListSec_2[sec] = true
				
				if (self.parts_match and sec == obj_s:section()) then
					local part_bonus = obj:condition()
					part_bonus = (game_achievements.has_achievement("mechanized_warfare")) and (part_bonus + 0.02) or part_bonus
					part_bonus = clamp(math.floor(part_bonus*100)*self.parts_multi , 0 , 100)
				
					size_t = size_t + 1
					inv[size_t] = obj
					inf[size_t] = part_bonus
				-- arti_outfits - use any outfit part
				elseif ((self.parts_sections and self.parts_sections[sec]) or (part_compatible(sec, self.section))) then
					local part_bonus = ini_sys:r_float_ex(sec,"repair_part_bonus") or self.part_bonus
                    local rank = rank_component(sec)
                    if rank == 3 or rank == 4 then part_bonus = 0.03 end
					part_bonus = (game_achievements.has_achievement("mechanized_warfare")) and (part_bonus + 0.02) or part_bonus
					part_bonus = clamp(math.floor(part_bonus*100)*self.parts_multi , 0 , 100)

					size_t = size_t + 1
					inv[size_t] = obj
					inf[size_t] = part_bonus
				end
			end
		end)
		
		self.CC[2]:Reinit(inv,inf)
		
		local clr_b = utils_xml.get_color("pda_blue",true)
		local fnt = GetFontSmall()
		for idx,ci in pairs(self.CC[2].cell) do
			if ci:IsShown() then
				local con100 = ci.flags.info
				local con = ci.flags.info / 100
				ci:Add_CustomText( ("+"..con100), nil, nil, clr_b, fnt)
			end
		end
	end
end

function item_repair.UIRepair:OnItemSelect(n)
	local obj_1 = self.CC[1]:GetCell_Selected(true) -- item to be fixed
	local obj_n = self.CC[n]:GetCell_Selected(true) -- support item
	if not (obj_1 and obj_n) then
		return
	end

	local sec = obj_n:section()
	local id = obj_n:id()
	local con = 0
	if n == 2 then
		local is_part_match = (self.parts_match and sec == obj_1:section())
		con = is_part_match and obj_n:condition() or ini_sys:r_float_ex(sec,"repair_part_bonus") or self.part_bonus
        local rank = rank_component(sec)
        if rank == 3 or rank == 4 then con = 0.03 end
		con = (game_achievements.has_achievement("mechanized_warfare")) and (con + 0.02) or con
		con = clamp(math.floor(con*100)*self.parts_multi , 0 , 100)
	end
	
	-- Text (Name)
	local name = ui_item.get_sec_name(sec)
	self.text_item[n]:SetText(name)
	
	-- Text (Condition)
	self.con_val[1] = math.ceil((obj_1:condition())*100) -- old condition
	self.con_val[2] = ((n == 2) and con) or 0 -- support bonus
	self.con_val[3] = math.floor((self.add_condition)*100) -- repair add
	self.con_val[4] = clamp(self.con_val[1] + self.con_val[2] + self.con_val[3], 0, 100) -- total condition (cap this)
    local maxCond = get_projected_max(obj_1, self.section, obj_n)
    print_dbg("Projected max is %s", maxCond)
	if IsItem("part",nil,obj_1) then
		self.con_val[4] = utils_item.get_cond_static(self.con_val[4])
	end
	
	self.con_txt[1]:SetText(utils_xml.get_color_con(self.con_val[1]) .. game.translate_string("st_ui_oldcon") .. ": +" .. self.con_val[1] .. "%")
	self.con_txt[2]:SetText(self.clr_b .. game.translate_string("st_ui_bonus") .. ": +" .. self.con_val[2] .. "%")
	self.con_txt_base:SetText(game.translate_string("st_ui_repair") .. ": " .. self.con_val[3] .. "%")
    local color_con = self.con_val[4] > maxCond and utils_xml.get_color_con(1) or utils_xml.get_color_con(self.con_val[4])
	self.con_txt_new:SetText(color_con .. game.translate_string("st_ui_total") .. ": " .. self.con_val[4] .. "/"..maxCond)
	
	-- Icon
	self.cell_item[n]:Set(obj_n)

	-- Reset supportive item when you choose main item
	if (n == 1) and self.use_parts then
		self.cell_item[2]:Reset()
		self.text_item[2]:SetText("")
	end
	
	self.btn_repair:Enable(true)
end

OnRepair = item_repair.UIRepair.OnRepair

function item_repair.UIRepair:OnRepair()	
	local obj_1 = self.CC[1]:GetCell_Selected(true)
	local obj_2 = self.CC[2]:GetCell_Selected(true)
	OnRepair(self)
    if has_parts(obj_1) then
        arti_outfits.repair_parts(obj_1, self.obj:section(), obj_2)
        arti_outfits.cap_condition(obj_1)
    end
end

local clr_g  = utils_xml.get_color("d_green")
local clr_y  = utils_xml.get_color("yellow")
local clr_o  = utils_xml.get_color("d_orange")
local clr_r  = utils_xml.get_color("d_red")

local clr_b  = utils_xml.get_color("d_cyan")
local clr_b1 = utils_xml.get_color("pda_blue")
local clr_b2 = utils_xml.get_color("d_blue")
local clr_p  = utils_xml.get_color("d_purple")

local clr_w  = utils_xml.get_color("pda_white")

local clr_1  = utils_xml.get_color("ui_gray_2")
local clr_2  = utils_xml.get_color("ui_gray_1")
BuildFooter = ui_item.build_desc_footer
function ui_item.build_desc_footer(obj, sec, str)
    str = BuildFooter(obj, sec, str)
    if repair_item_restoration[sec] then
        str = str:sub(1, -3)
        local rest = repair_item_restoration[sec]
        local repair = {}
        for k,v in pairs(rest[2]) do
            repair[#repair+1] = k
        end
        str = str .. clr_o .. " " .. gc("st_dot") .. " " .. clr_1 .. " " .. gc("st_total_repair") .. " " .. rest[1].. "-" .. 3*rest[1] .. "%\\n"
        str = str .. clr_o .. "  " .. gc("st_dot") .. " " .. clr_1 .. " " .. gc("st_can_repair") .. " " .. gc("st_type_"..repair[1])
        for i=2,#repair  do
            str = str .. ", " .. gc("st_type_"..repair[i])
        end
        str = str .. "\\n\\n"
    end
    return str
end
-- end monke

local function actor_item_to_belt(obj)
    update_immunities()
end

local function actor_item_to_slot(obj)
    if IsOutfit(obj) then
        update_immunities()
    end
end

function on_game_start()
    for i=1,20 do
        parts_map["prt_o_ballistic_"..i] = "prt_o_ballistic"
        parts_map["prt_o_retardant_"..i] = "prt_o_retardant"
    end
    for i=1,4 do
        parts_map["prt_o_fabrics_"..i] = "prt_o_fabrics"
    end
    parts_map["prt_o_support"] = "prt_o_support"
	RegisterScriptCallback("ActorMenu_on_item_drag_drop",on_item_drag_dropped)
    RegisterScriptCallback("actor_on_before_hit",actor_on_before_hit)
    RegisterScriptCallback("actor_item_to_belt",actor_item_to_belt)
    RegisterScriptCallback("actor_item_to_slot",actor_item_to_slot)
    RegisterScriptCallback("actor_on_update",actor_on_update)
end